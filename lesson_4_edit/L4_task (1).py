"""
Задание 1.

Приведен код, который позволяет сохранить в
массиве индексы четных элементов другого массива

Сделайте замеры времени выполнения кода с помощью модуля timeit

Оптимизируйте, чтобы снизить время выполнения
Проведите повторные замеры

Добавьте аналитику: что вы сделали и почему!!!
Без аналитики задание считается не принятым
"""
# timeit doc

from timeit import timeit
from itertools import filterfalse


# Среднеяя скорость
def func_1(nums):
    new_arr = []
    for el in nums:
        if el % 2 == 0:
            new_arr.append(el)
    return new_arr


# Медленно
def func_2(nums):
    data = list(filterfalse(lambda x: x % 2 != 0, nums))
    return data


# Быстро
def func_3(nums):
    return [el for el in nums if el % 2 == 0]


num = [el for el in range(1, 30)]



print(timeit("func_1(num)", globals=globals()))
print(timeit("func_2(num)", globals=globals()))
print(timeit("func_3(num)", globals=globals()))


"""
Последние замеры: 
4.012612
6.097696200000001
3.2113963000000005

После исправления первой функции время её обработки уменьшилось. 
Далее были добавлены два алгоритмы для получения четных чисел из списка. Функция два изпользует модуль итертулс,
однако при весьма коротком решении (одна строка), скорость обработки самая высокая. Скорее всего это связано с 
лямбда функцией. Рекордсменом стал генератор - функция 3.  
"""